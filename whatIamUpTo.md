Beware, this file loses content as I get stuff done, anything worth remembering becomes comments on the code. 

# Locally

- [x] Design cloud
- [x] Recreate locally
- [x] Add Talos OS to it
- [x] Add Flux
- [x] Run podinfo as a template for everything else

## On his cloud
- [x] Add Talos to the current cloud using his image
	- [x] Added label controlplane
- [x] Assign private IPs to simplify Talos Bootstraping
- [x] Bootstrap Talos directly from Terraform
- [x] Add Flux
- [x] Add anything using Terraform AND Flux like Podinfo
- [x] Add an Traefik as Ingress
- [x] Add Cert-Manager
- [x] Add CSI as Storage classes.
- [x] Add Velero
- [x] Sort the creation order in both Terraform and Flux
- [ ] Clean up vars, organise secrets

## Talos Boostrapping

It's all done mostly in talos-config.tf

#### Configuring talosctl

To use the talosconfig generated by Terraform use

```sh
terraform output -json talos_talosconfig | jq -r . > /tmp/talosconfig  && export TALOSCONFIG=/tmp/talosconfig
```

#### Configuring kubectl

Use this so you can use kubectl and the common alias you've always used

```bash
talosctl kubeconfig /tmp/kubeconfig && export KUBECONFIG=/tmp/kubeconfig && alias k=kubectl
```

Both combined:

```bash
terraform output -json talos_talosconfig | jq -r . > /tmp/talosconfig  && export TALOSCONFIG=/tmp/talosconfig && talosctl kubeconfig /tmp/kubeconfig --force && export KUBECONFIG=/tmp/kubeconfig && alias k=kubectl
```

Now to simply check the nodes with full details

```sh
kubectl get nodes -o wide
```

You can see the dashboard either by console into any server from Hetzner cloud or simply

```sh
talosctl dashboard
```

# Adding Flux & Bootstrapping it

The most **important** part of Flux is that the kube credentials passed from Talos need to be byte64decoded and **that's nowhere in the docs**

Interestingly enough if you destroy the infrastructure, the folder of Flux in the repo you named gets destroyed too, not the entire repo. So you're suppose to use Terraform to start a Flux deployment with some initial stuff and then let it run. If you destroy the deployment TF assumes you don't need that folder either. 

### Credentials for Github

These are described in variables.tf and added out of the repo in terraform.tfvars

### Manually adding Flux sources

```sh
flux create source git podinfo \
  --url=https://github.com/stefanprodan/podinfo \
  --branch=master \
  --interval=1m \
  --export > ./clusters/my-cluster/podinfo-source.yaml
```

Then commit and push, Flux will update it. In k9s you can find it as GitRepository

### Manually adding kustomizations

```sh
flux create kustomization podinfo \
  --target-namespace=default \
  --source=podinfo \
  --path="./kustomize" \
  --prune=true \
  --wait=true \
  --interval=30m \
  --retry-interval=2m \
  --health-check-timeout=3m \
  --export > ./clusters/my-cluster/podinfo-kustomization.yaml
Instructions: https://fluxcd.io/flux/get-started/
```

Commit and push again. 

Even though you don't have an ingress yet you can check podinfo with 

```sh
kubectl port-forward service/podinfo 9898:9898 
```

Check errors with

```sh
flux events
```

Saves you from using K9s
# Adding ingress

Stephen ingress of choice is my favourite: Traefik

Ingress won't work without persistent volumes because Traefik needs some PVCs. Its pod is stuck because of this. 

# Adding Cert-Manager

Created a namespace
Beware certs are deployed differently, same as traefik and ingress are two separated things. 

J-F-C it was as simple as putting the release and the source in the same namespace and not the mess described [here](https://github.com/fluxcd/flux2/discussions/3009)

The way to solve the CRD install conundrum is to modify the hell release to add the installCRDs=true clause as values not extra args, not args. Like this

```yaml
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: cert-manager
  namespace: cert-manager
spec:
  interval: 5m
  chart:
    spec:
      chart: cert-manager
      version: 'v1.9.1'
      sourceRef:
        kind: HelmRepository
        name: jetstack
  values:
    installCRDs: true
  releaseName: cert-manager
```

I've added all stuff for the ingress in the ingress folder including the certificate issuer and actual certs. 


# Adding Persistence

Remember this needs secrets.yaml to work

Created a namespace called Hetzner

Bware how you apply the secret because that's not on the repo. 

Will need to add labels to workers as 

```bash
kubectl label nodes <node-name> node-role.kubernetes.io/worker=true
```

They need to be created on kube-system namespace


# Adding Velero

Beware the secret needs the namespace

Created a namespace
# Issues to fix before it's finished

##### 1. Stuck in fluxboostrapgit.this
Here:

```bash
flux_bootstrap_git.this: Still creating... [1m10s elapsed]
│ Error: Bootstrap run error
│
│   with flux_bootstrap_git.this,
│   on flux.tf line 37, in resource "flux_bootstrap_git" "this":
│   37: resource "flux_bootstrap_git" "this" {
│
│ CustomResourceDefinition/alerts.notification.toolkit.fluxcd.io dry-run failed: Get "https://167.235.111.172:6443/api?timeout=32s": EOF
```
It creates the public key but tries to start up Flux before the Talos cluster is ready. 

Let's see first if I can make it depend on Talos being boostrapped. 

The next error is stuck in cert-manager

```bash
Kustomization/flux-system	kustomize build failed: accumulating resources: accumulation err='accumulating resources from './cert-manager': read /tmp/kustomization-2443421633/clusters/steph/cert-manager: is a directory': couldn't make target for path '/tmp/kustomization-2443421633/clusters/steph/cert-manager': invalid Kustomization: json: unknown field "specs"	           
```

When everything is move outside the cluster/steph folder and only left the bits of Flux, it works. 
Trying now from scratch deleting also that folder after a terraform destroy didn't. 

Fixed it by using talos_cluster_health as stopper (dependecy) for the Flux part. 
Fixed the within-Flux part by moving everything out of the cluster folder and inside a different one, otherwise Flux follows its own order. 

##### 2. Make everything a variable

TODO:
